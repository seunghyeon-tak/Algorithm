## 가장 가까운 같은 글자

### 문제 요약

- 문자열 s가 주어졌을때 
- 각 인덱스 i마다
  - s[i]와 같은 글자 중에서
  - 자신보다 앞에 있으면서
  - 가장 가까운 위치와의 거리를 구해 배열로 반환하는 문제
- 만약 같은 글자가 한번도 앞에 나오지 않았다면 -1을 넣는다.

### 접근 방식

- HashMap<Character, Integer>를 사용해 각 문자별 마지막 등장 위치(인덱스)를 저장한다.
- 문자열 왼쪽부터 순회하면서
  - 현재 문자 c = s.charAt(i)가 map에 이미 존재한다면
  - i - map.get(c)를 계산해 가장 가까운 같은 글자와의 거리를 answer 배열에 저장
  - 존재 하지 않는다면 answer 배열에 -1로 저장한다.
- 이후에는 항상 map.put(c, i)를 호출해 현재 인덱스를 해당 문자의 마지막 등장 위치로 갱신한다.

### 왜 이런 방식으로 풀었나?

- 각 위치마다 왼쪽 전체를 다시 탐색하면 O(n^2) 시간이 걸리는데
- HashMap에 마지막으로 등장한 인덱스만 저장 해두면 매 위치에서 O(1)시간 만에 거리를 계산할 수 있어 전체 시간 복잡도를 O(n)으로 줄일 수 있다.
- 같은 글자가 여러번 등장하더라도 HashMap의 같은 Key에 대한 덮어쓰기 특성을 이용해 가장 최근에 등장한 위치만 유지 할 수 있어 구현이 간단하다.

### 다른 방식으로 풀었을때 좋은점? (혹은 안좋은점)

- int[] 배열 사용 방법
  - int[26] 같은 배열에 마지막 인덱스를 저장하는 방식
  - 장점
    - hashmap보다 오버헤드가 적어 더 빠르고 메모리 사용도 단순
  - 단점
    - 문자 종류가 고정/제한적일 때만 사용 가능하고
    - 유니코드, 한글 등 다양한 문자에 대해서는 일반화가 어렵다