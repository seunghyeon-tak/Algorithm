## 옹알이(2)

### 문제 요약

- 문자열 배열 babbling이 주어진다.
- 각 문자열은 다음 4개의 발음 조각 중 일부를 이어붙여 만든 것이다
  - "aya", "ye", "woo", "ma"
- 단, 같은 발음 조각을 연속해서 말할 수 없다.
- 위 규칙을 만족하면서 만들 수 있는 문자열의 개수를 구하는 문제이다.

### 접근 방식

- 각 문자열 b에 대해
  - pos를 0으로 두고 시작한다
  - pos 위치에서 aya, ye, ma, woo 중 하나로 시작하는지 확인한다
    - startswith()를 사용해서 인덱스 위치와 그에 만족하는 문자열을 찾을 수 있다.
  - 시작하는 토큰 t를 찾으면
    - 직전에 사용한 토큰 prev와 t가 같으면 연속 사용이므로 실패 처리
    - 같지 않으면 pos += t.length() 만큼 이동해서 해당 토큰을 지운것 처럼 처리
    - 그리고 prev = t로 갱신한다.
  - 4개 토큰 중 어느것도 매칭이 안되면 더 진행이 불가능하므로 실패 처리한다.
  - 끝까지 (pos == b.length()) 무사히 도달하면 그 문자열은 규칙을 만족하므로 카운트 한다.

### 왜 이런 방식으로 풀었나?

- 처음에는 contains와 replace로 접근하려고 했지만,
  - 문자열 중간에 토큰이 있어도 통과하는 오류가 나거나 반복되는 패턴에서 한번에 여러개기 지워지는 문제가 생기는걸 확인했다.
- 반면 포인터로 왼쪽부터 확인하면
  - 항상 현재 위치에서 시작하는 토큰만 검사하므로 규칙을 정확히 지킬 수 있고
  - 한 번 토큰이 매칭될 때마다 pos가 앞으로 이동하므로 흐름이 단순해진다.
- 연속 사용 금지는 prev 하나만 기억하면되므로 바로 처리할 수 있어서 구현이 깔끔해진다.

### 다른 방식으로 풀었을때 좋은점? (혹은 안좋은점)

- 